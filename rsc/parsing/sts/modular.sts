;; node a (in: bool) returns (out: int) ;
;; let
;;   out = (
;;    if in then 1 else 0
;;  ) -> (
;;    if in then pre out + 1 else pre out
;;  ) ;
;;  --%PROPERTY out >= 0 ;
;; tel

;; Defines a state with named state variables.
(define-state state_of_a
  (in Bool) (out Int)
)

;; Defines a initial predicate over some state.
;; Same as
;; > (define-fun init_of_a ((state.in Bool) (state.out Bool)) ...)
;; but allows usage in `define-system` as first argument (see below).
(define-init init_of_a state_of_a
  (ite (state in) (= (state out) 1) (= (state out) 0))
)

;; Defines a transition predicate over some state.
(define-trans trans_of_a state_of_a
  (ite (next in) (= (next out) (+ (state out) 1)) (= next.out (state out)))
)

;; Defines a transition system from some initial and transition predicates.
(define-system sys_a state_of_a
  init_of_a
  trans_of_a
)

;; Defines a predicate over a state.
(define-pred out_positive state_of_a
  (>= (state out) 0)
)



;; node b (act, deact: bool) returns (out: int) ;
;; let
;;   out = a( act and pre not deact ) ;
;;   --%PROPERTY (act and not deact) => ( out = (0 -> pre out + 1) ) ;
;; tel

(declare-fun oracle () Bool)

(define-state state_of_b
  ;; Traceable inputs/outputs as quoted idents.
  (       |input(b,act)| Bool)
  (     |input(b,deact)| Bool)
  (|pre(input(b,deact))| Bool)
  (      |output(b,out)| Int )
  ( |pre(output(b,out))| Int ) ;; For the property.
)

(define-pred |prop(b,1)| sys_b
  (=> 
    ( or (not (state |input(b,act)|)) (state |pre(input(b,deact))|) )
    (= (state |output(b,out)|) (state |pre(output(b,out))|))
  )
  ;; 'state.' is mandatory to distinguish with "constants" (e.g. `oracle`).
)

(define-pred |cand(b,1)| sys_b
  (=>
    ( and (state |input(b,act)|) (not (state |input(b,deact)|)) )
    (= (state |output(b,out)|) (+ (state |pre(output(b,out))|) 1))
  )
)

(define-init init_of_b state_of_b
  (and
    (= (state |pre(input(b,deact))|) oracle)
    ;;                             ^^^^^^~~~ Not a state var.
    ;; 'state.' is mandatory to distinguish with "constants" (e.g. `oracle`).
    (= (state |pre(output(b,out))|) true)
    ;; init_of_a can be used as
    ;; > (define-fun init_of_a ((in Bool) (out Bool)) ...)
    ;; That is, consistently with its state signature.
    (init_of_a
      ;; (in Bool)
      (and
        (state |input(b,act)|)
        (not (state |pre(input(b,deact))|))
      )
      ;; (out Int)
      (state |output(b,out)|)
    )
  )
)

(define-trans trans_of_b state_of_b
  (and
    (= (next |pre(input(b,deact))|) (state |input(b,deact)|))
    (= (next |pre(output(b,out))|) (state |output(b,out)|))
    ;; trans_of_a can be used as
    ;; > (define-fun trans_of_a ((in Bool) (out Bool)) ...)
    ;; That is, consistently with its _state_ signature.
    (trans_of_a
      (and
        (next |input(b,act)|)
        (not (next |pre(input(b,deact))|))
      )
      (next |output(b,out)|)
    )
    ;; Under the hood:
    ;; > (trans_of_a
    ;; >   (and
    ;; >     |state.input(b,act)|
    ;; >     (not |state.pre(input(b,deact))|)
    ;; >   )
    ;; >   |state.output(b,0)|
    ;; >   (and
    ;; >     |next.input(b,act)|
    ;; >     (not |next.pre(input(b,deact))|)
    ;; >   )
    ;; >   |next.output(b,0)|
    ;; > )
  )
)

(define-system sys_b state_of_b
  init_of_b
  trans_of_b
)

( check sys_b (|prop(b,1)|) (|cand(b,1)|) )
